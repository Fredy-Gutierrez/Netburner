/*
 * DBTrainDriver.cpp
 *
 *  Created on: 24 mar 2022
 *      Author: Integra Fredy
 */
#include "libs/DBTrainDriver.h"
#include "libs/Default_Values.h"
#include "libs/SDCardDriver.h"
#include "libs/Rtc_Controller.h"
#include "libs/Train.h"
#include "libs/Business.h"
#include <stdlib.h>
#include <stdio.h>

TrainControl controlTrain = { {'0','3','0','6','2','0','2','2','\0'} , 0, {'0','3','0','6','2','0','2','2','\0'} , 0, 0 };

SDTrainUsers * userRW;//user request pointer

RequestState UserDBRequest = StNoRequest;

/*******************CREATES THE BASE DIRECTORIES FOR TRAINS*********************/
bool createDirectories(){
	f_chdrive(EXT_FLASH_DRV_NUM);
	if(MakeDir("/DB")){
		if(MakeDir(BASETRAINDIR)){
			if(MakeDir(BASETRAINDATADIR)){
				return true;
			}
		}
	}
	return false;
}

/*******************OVERWRITE THE TRAIN CONTROL*********************/
void overwriteTrainControl(){
	MoveToDirectory(BASETRAINDIR);//Move the file system to route "/DB/Trains"
	FN_FILE * fp = OpenFile(CONTROLTRAINFILE, "w+");//Open file as write mode
	if(fp){
		SDWrite(&controlTrain, sizeof(controlTrain), fp);//write train control structure
		CloseFile(fp);//close file
	}
	MoveToDirectory("/");//Move the file system to root
}

void printTrainControlInfo(){
	logg.newPrint("\nWrite day: %s train number: %d", controlTrain.DayDirWrite, controlTrain.TrainNumWrite);
	logg.newPrint("\nRead day: %s train number: %d", controlTrain.DayDirRead, controlTrain.TrainNumRead);
}

/*******************READ THE TRAIN CONTROL*********************/
void readTrainControl(){
	createDirectories();//Makes train directories
	MoveToDirectory(BASETRAINDIR);//Moves file system to train directory DB/Trains
	FN_FILE * fp = OpenFile(CONTROLTRAINFILE, "r");//Open file as read mode
	if(fp){
		SDRead( (void *)&controlTrain, sizeof(TrainControl), fp );//read train control structure
		CloseFile(fp);//close file
	}else{
		//if file not exist it will create the file
		overwriteTrainControl();
	}
	MoveToDirectory("/");//Move the file system to root
}

/********************************MOVES THE FILE SYSTEM TO PATH *********************************/
bool useTrainDirectory(RequestType request, bool useTrainControl = true){
	char trainFolder[9];//ddMMyyyy
	char fullPath[20];//FULL PATH DB/TRAINS/ddMMyyyy

	memset(fullPath,'\0',20);
	memset(trainFolder,'\0',9);

	if(useTrainControl){
		if(request == ReadRequest || request == OverWriteRequest){
			memcpy(trainFolder, controlTrain.DayDirRead, sizeof(trainFolder));
		}else{
			/********************WHEN REQUEST IS WRITE AND THE USER IS USING THE CONTROLTRAIN, WE WILL GET THE DAY DIRECTORY*****************************/
			getDateIntoBuffer(trainFolder, '\0');//GETS THE DATE AS ddMMyyyy TO USE OR CREATE THE DAY FOLDER
			trainFolder[8] = '\0';
			int datesCom = compareDates(controlTrain.DayDirWrite, trainFolder);//COMPARE TWO (CHAR *) DATES TO KNOW WHICH IS HIGHEST
			if( datesCom < 0 ) {//IF ACTUAL CONTROL DAYWRITE IS LOWER THAN SYSTEMDATE
				memcpy(controlTrain.DayDirWrite, trainFolder, sizeof(trainFolder));//CHANGE THE DAYWRITE TO SYSTEMDATE
				controlTrain.TrainNumWrite = 0;//RESTART THE TRAIN NUMBER FOR NEW DAY
				overwriteTrainControl();//SAVE THE TRAIN CONTROL INTO .bin
			}else if(datesCom > 0){//IF ACTUAL CONTROL DAYWRITE IS HIGHER THAN SYSTEMDATE
				memcpy(trainFolder, controlTrain.DayDirWrite, sizeof(trainFolder));
			}
		}
		sprintf(fullPath, "%s/%s", BASETRAINDIR, trainFolder);//MAKES THE FULL PATH
	}else{
		memcpy(fullPath, userRW->path, sizeof(userRW->path));//MAKES THE FULL PATH USING THE PATH THAT USER WANT
	}

	f_chdrive(EXT_FLASH_DRV_NUM);//TO CREATE OR USE OTHER PATHS FOLDERS IN SDCARD

	MakeDir(fullPath);//CREATE THE PATH IF NOT EXIST

	if(!MoveToDirectory(fullPath)){//MOVES THE FILESYSTEM TO EXISTING PATH
		return false;
	}
	return true;
}

/******************************************MAKES A TRAIN FILE NAME USING A SECUENCES*************************
 * 		TRAIN FILE FORMAT		-> 			Train000001.bin
 *
 * 		@nFileName				->			Buffer to store the train name Generated by function
 * 		@sequence				->			Train file sequence
 * */
void makeTrainFileName(char * nFileName, int secuence){
	char fileName[16+sizeof(char)];
	memset(fileName, 0, 16 * (sizeof fileName[0]) );
	char num_char[6+sizeof(char)];
	sprintf(num_char, "%06d", secuence);
	strcpy(fileName, "Train");
	strcat(fileName, num_char);
	strcat(fileName, ".bin");
	memcpy(nFileName, fileName, sizeof(fileName));
}

/******************************************WRITE REQUEST, IT CREATES A NEW TRAINFILE TO STORE A COMPLETE TRAIN INTO DBTRAINS*****************************
 * IF USER USE THE TRAINCONTROL, IT WILL WRITE THE TRAIN INTO THE TRAINCONTROLPATH. IF NOT, IT WILL WRITE THE TRAIN INTO PATH THAT USER WANT AND WILL MAKE THE TRAIN FILE WITH USER FILENAME
 **/
void writeTrainIntoDB(){
	char fileName[16 + sizeof(char)];

	useTrainDirectory(WriteRequest, userRW->useTrainControl);//use the path where the file will be create
	if(userRW->useTrainControl){
		makeTrainFileName(fileName, controlTrain.TrainNumWrite + 1);//assign the filename making it with control train write sequence
	}else{
		memcpy(fileName, userRW->fileName, sizeof(userRW->fileName));//assign the filename that user want to use
	}

	FN_FILE * fp = OpenFile(fileName, "w+");//open file as write mode
	if(fp){
		int rv = SDWrite(userRW->train, CalcTrainSize(userRW->train), fp);//write train
		CloseFile(fp);//close train file
		if(userRW->modReqStFlag){
			if(rv > 0){
				userRW->stateRequest = StCompletedReq;
			}else{
				userRW->stateRequest = StNoRequest;
			}
		}
	}else{
		if(userRW->modReqStFlag){
			userRW->stateRequest = StNoRequest;
		}
	}

	MoveToDirectory("/");//return the file system to root path

	if(userRW->useTrainControl){//if user is using train control it will update the train write number
		controlTrain.TrainNumWrite = controlTrain.TrainNumWrite + 1;
		controlTrain.TrainToSend = controlTrain.TrainToSend + 1;
		overwriteTrainControl();
	}
}

/******************************************OVERWRITE REQUEST, IT OVERWRITE A TRAIN STORED INTO DBTRAINS*****************************
 * 	IF USER USE THE TRAINCONTROL, IT WILL OVERWRITE THE TRAIN INTO THE TRAINCONTROLPATH. IF NOT, IT WILL OVERWRITE THE TRAIN INTO PATH THAT USER WANT AND WILL MAKE THE TRAIN FILE WITH USER FILENAME
 *
 *	THE DEFAULT USE IS FOR TRAINS THAT HAVE BEEN REPORTED TO SERVER, SO THE REPORTEDFLAG HAS BEEN UPDATED, IT WILL OVERWRITE THE
 *	TRAIN INFORMATION IN DB TO SAID THAT THE TRAIN HAS BEEN REPORTED AND INCREMENT THE READ SECUENCE FOR READ REQUEST
 **/
void overWriteTrain(){
	char fileName[16 + sizeof(char)];

	useTrainDirectory(OverWriteRequest, userRW->useTrainControl);//use the path where the file will be create
	if(userRW->useTrainControl){
		makeTrainFileName(fileName, controlTrain.TrainNumRead + 1);//assign the filename making it with control train write sequence
	}else{
		memcpy(fileName, userRW->fileName, sizeof(userRW->fileName));//assign the filename that user want to use
	}

	FN_FILE * fp = OpenFile(fileName, "w");//open file as write mode
	if(fp){
		int rv = SDWrite(userRW->train, CalcTrainSize(userRW->train), fp);//overwrite train
		CloseFile(fp);//close train file
		if(userRW->modReqStFlag){
			if(rv > 0){
				userRW->stateRequest = StCompletedReq;
			}else{
				userRW->stateRequest = StNoRequest;
			}
		}
	}else{
		userRW->stateRequest = StNoRequest;
	}

	MoveToDirectory("/");//return the file system to root path

	if(userRW->useTrainControl){//if user is using train control it will update the train read number
		controlTrain.TrainNumRead = controlTrain.TrainNumRead + 1;
		if(controlTrain.TrainToSend > 0){
			controlTrain.TrainToSend = controlTrain.TrainToSend - 1;
		}
		overwriteTrainControl();
	}
}

/******************************************READ REQUEST, IT READ A TRAIN STORED INTO DBTRAINS*****************************
 * 	IF USER USE THE TRAINCONTROL, IT WILL READ THE NEXT TRAIN IN THE TRAINCONTROLPATH. IF NOT, IT WILL READ THE TRAIN INTO PATH THAT USER WANT
 *	IF USING TRAINCONTROL, AND THERE IS NOT TRAINS TO READ
 **/
void readNextTrain(){
	bool lecture = false;
	while(!lecture){//until a train is read or there is not trains in folder to read or if user is using the train control it will look for next train moving the day folder to next upto dayread equals daywrite
		char fileName[16 + sizeof(char)];

		useTrainDirectory(ReadRequest, userRW->useTrainControl);//use the path where the file will be read
		if(userRW->useTrainControl){
			makeTrainFileName(fileName, controlTrain.TrainNumRead + 1);//assign the filename making it with control train write sequence
		}else{
			memcpy(fileName, userRW->fileName, sizeof(userRW->fileName));//assign the filename that user want to use
		}

		FN_FILE * fp = OpenFile(fileName, "r");//open file as read mode

		if(fp){
			int rv = SDRead(userRW->train, sizeof( typeTrain ), fp);//read train
			CloseFile(fp);//close train file
			if(userRW->modReqStFlag){
				if(rv > 0){
					userRW->stateRequest = StCompletedReq;
				}else{
					userRW->stateRequest = StNoRequest;
				}
			}

			lecture = true;//to close while
		}else{//if couldn´t open file
			if(userRW->useTrainControl){//if user is using the train control
				if(compareDates(controlTrain.DayDirRead, controlTrain.DayDirWrite) < 0){//if day read is lower than day write, the day read directory has been completely read, so we must move to next directory
					controlTrain.TrainNumRead = 0;
					addDaysTo(controlTrain.DayDirRead, controlTrain.DayDirRead, 1);//add one day to read date
					overwriteTrainControl();//overwrite train control because we change the read parameters
				}else{//if day read is not lower than day write
					if(userRW->modReqStFlag){
						userRW->stateRequest = StNoRequest;
					}
					lecture = true;//to close while
				}
			}else{//if user is not using the train control
				if(userRW->modReqStFlag){
					userRW->stateRequest = StNoRequest;
				}
				lecture = true;//to close while
			}
		}
		MoveToDirectory("/");//return the file system to root path
	}
}

void processTrainRequest(){
	useTrainDirectory(userRW->request, userRW->useTrainControl);//use the path where the file will be read
	char fileName[16 + sizeof(char)];

	switch(userRW->request){
		case ReadRequest:

			if(userRW->useTrainControl){
				makeTrainFileName(fileName, controlTrain.TrainNumRead + 1);//assign the filename making it with control train write sequence
			}else{
				memcpy(fileName, userRW->fileName, sizeof(userRW->fileName));//assign the filename that user want to use
			}


			break;
		case WriteRequest:

			if(userRW->useTrainControl){
				makeTrainFileName(fileName, controlTrain.TrainNumWrite + 1);//assign the filename making it with control train write sequence
			}else{
				memcpy(fileName, userRW->fileName, sizeof(userRW->fileName));//assign the filename that user want to use
			}


			break;
		case OverWriteRequest:
			break;
	}

	MoveToDirectory("/");//return the file system to root path
}

/******************************************FOR NEW USER REQUEST*****************************
	@user			->			User pointer where is the request data
 **/
bool newRequest(SDTrainUsers * user){
	if(UserDBRequest != StNoRequest){
		return false;
	}
	userRW = user;
	if(userRW->modReqStFlag){
		userRW->stateRequest = StInProgressReq;
	}
	UserDBRequest = StInProgressReq;
	return true;
}

/******************************************MAIN TASK FOR DBTRAIN PROCESS*******************************/
void DBTrainProcess(void * pd){
	DBState DBProcessState = StDbInit;//controls DB task
	AddFSTask();//ADDTASK TO USE THE SDCARD
	while(1){
		switch(DBProcessState){
			case StDbInit:
				InitExtFlash();//MOUNTS THE SDCARD
				DBProcessState = StDbStart;
				break;
			case StDbStart:
				readTrainControl();
				DBProcessState = StDbWait;
				break;
			case StDbWait:
				if(UserDBRequest != StNoRequest){
					switch(userRW->request){
						case ReadRequest:
							DBProcessState = StDbReadTrain;
							break;
						case WriteRequest:
							DBProcessState = StDbWriteTrain;
							break;
						case OverWriteRequest:
							DBProcessState = StDbOverWriteTrain;
							break;
					}
				}
				OSTimeDly(10);//wait 500ms
				break;
			case StDbWriteTrain:
				writeTrainIntoDB();
				UserDBRequest = StNoRequest;
				DBProcessState = StDbWait;
				break;
			case StDbReadTrain:
				readNextTrain();
				UserDBRequest = StNoRequest;
				DBProcessState = StDbWait;
				break;
			case StDbOverWriteTrain:
				overWriteTrain();
				UserDBRequest = StNoRequest;
				DBProcessState = StDbWait;
				break;
		}
	}
}

/******************************************INIT TASK FOR DBTRAIN PROCESS*******************************/
void InitDBTrain(){
	OSSimpleTaskCreatewName(DBTrainProcess, DBTRAIN_PRIO, "TaskDBTrain");
}

/******************************************RETURN THE QUANTITY OF TRAINS THAT MUS BE SEND*******************************/
uint32_t getQtyTrainsToSend(){
	return controlTrain.TrainToSend;
}
